# .gitlab/build.gitlab-ci.yml
# Reusable Docker build+push template.

# --- DinD base (reusable) ---
.build-dind:
  image: docker:24.0.5
  services: ["docker:24.0.5-dind"]
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""

# --- Build Image Template (reusable) ---
.build_image_template:
  extends: .build-dind
  variables:
    # Behavior toggles (safe defaults)
    PUSH_IMAGE: "false"            # auto-set true for tags/env branches (and feature when PUSH_ON_FEATURE=true)
    PUSH_ON_FEATURE: "false"       # allow pushing on feature branches
    TAG_LATEST: "false"            # auto true for prod branch; also true on tag pipelines
    TAG_SUFFIX: ""                 # can override; "latest" is forbidden
    DOCKER_CONTEXT: "."
    DOCKERFILE: "Dockerfile"

    # Suffix presets
    DEV_TAG_SUFFIX: "dev"
    TEST_TAG_SUFFIX: "test"
    INT_TAG_SUFFIX:  "int"
    PROD_TAG_SUFFIX: "prod"
    FEATURE_TAG_SUFFIX: "feat"
    MR_TAG_SUFFIX: "mr"
    FEATURE_PREFIX: "gmarm-"

    # Optional: set APP_NAME to append to repo path and sanitize
    APP_NAME: ""

  script: |
    set -euo pipefail

    # ---------- CI Awareness ----------
    IS_CI="${GITLAB_CI:+1}"
    IS_TAG="${CI_COMMIT_TAG:+1}"
    IS_MR="" && [[ "${CI_PIPELINE_SOURCE:-}" == "merge_request_event" ]] && IS_MR=1

    # Prefer job token in CI, else local PAT/deploy token
    if [[ -n "${IS_CI}" ]]; then
      TOKEN_TYPE="JOB"
      BUILD_TOKEN="${CI_JOB_TOKEN}"
      REGISTRY_USER="${CI_REGISTRY_USER}"
      REGISTRY_HOST="${CI_REGISTRY}"
    else
      TOKEN_TYPE="${TOKEN_TYPE:-PRIVATE}"
      BUILD_TOKEN="${GITLAB_TOKEN:-}"
      REGISTRY_USER="${GITLAB_USERNAME:-${REGISTRY_USER:-}}"
      REGISTRY_HOST="${REGISTRY:-${CI_REGISTRY:-}}"
    fi

    # ---------- Branch helpers ----------
    FEATURE_PREFIX="${FEATURE_PREFIX:-gmarm-}"
    SRC_BRANCH="${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME:-${CI_COMMIT_BRANCH:-}}"
    is_env_branch()     { [[ "${SRC_BRANCH}" =~ ^(dev|test|int|prod)$ ]]; }
    is_feature_branch() { [[ "${SRC_BRANCH}" == "${FEATURE_PREFIX}"* ]]; }

    # ---------- PUSH defaulting (safe by default) ----------
    if [[ -z "${PUSH_IMAGE:-}" ]]; then
      if [[ -n "${IS_CI}" ]]; then
        if [[ -n "${IS_TAG}" || is_env_branch ]]; then
          PUSH_IMAGE="true"
        elif is_feature_branch && [[ "${PUSH_ON_FEATURE:-false}" == "true" ]]; then
          PUSH_IMAGE="true"
        else
          PUSH_IMAGE="false"
        fi
      else
        PUSH_IMAGE="false"
      fi
    fi

    # ---------- Repo naming ----------
    if [[ -n "${APP_NAME:-}" ]]; then
      APP_NAME="$(printf '%s' "${APP_NAME}" | tr '[:upper:] ' '[:lower:]-' | tr -cd 'a-z0-9._-')"
      [[ -n "${APP_NAME}" ]] || { echo "bad APP_NAME"; exit 1; }
    fi

    IMAGE_REPO="${CI_REGISTRY_IMAGE:-local/${APP_NAME:-app}}"
    if [[ -n "${APP_NAME:-}" ]]; then
      IMAGE_REPO="${CI_REGISTRY_IMAGE:-local}/${APP_NAME}"
    fi

    # ---------- Tag selection ----------
    if [[ -n "${IS_TAG}" ]]; then
      BASE_TAG="${CI_COMMIT_TAG}"
      RELEASE_IMAGE="true"
    else
      BASE_TAG="${CI_COMMIT_SHORT_SHA:-dev}"
    fi

    # ---------- Auto suffix (overridable by TAG_SUFFIX) ----------
    case "${CI_PIPELINE_SOURCE:-}:${SRC_BRANCH:-}" in
      merge_request_event:*) TAG_SUFFIX="${TAG_SUFFIX:-${MR_TAG_SUFFIX:-mr}}" ;;
      *:dev)                 TAG_SUFFIX="${TAG_SUFFIX:-${DEV_TAG_SUFFIX:-dev}}" ;;
      *:test)                TAG_SUFFIX="${TAG_SUFFIX:-${TEST_TAG_SUFFIX:-test}}" ;;
      *:int)                 TAG_SUFFIX="${TAG_SUFFIX:-${INT_TAG_SUFFIX:-int}}" ;;
      *:prod)                TAG_SUFFIX="${TAG_SUFFIX:-${PROD_TAG_SUFFIX:-prod}}"; TAG_LATEST="${TAG_LATEST:-true}" ;;
      *:${FEATURE_PREFIX}*)  TAG_SUFFIX="${TAG_SUFFIX:-${FEATURE_TAG_SUFFIX:-feat}}" ;;
      *) : ;;
    esac

    [[ "${TAG_SUFFIX:-}" != "latest" ]] || { echo "TAG_SUFFIX cannot be 'latest'"; exit 1; }
    IMAGE_TAG="${TAG_SUFFIX:+${TAG_SUFFIX}-}${BASE_TAG}"
    IMAGE_TAG="$(printf '%s' "${IMAGE_TAG}" | tr ' /' '--' | tr -cd '[:alnum:]._-')"

    echo "---- build flags ----"
    echo "CI?               : ${IS_CI:+yes}"
    echo "MR?               : ${IS_MR:+yes}"
    echo "TAG pipeline?     : ${IS_TAG:+yes}"
    echo "SRC_BRANCH        : ${SRC_BRANCH:-<none>}"
    echo "TOKEN_TYPE        : ${TOKEN_TYPE}"
    echo "PUSH_ON_FEATURE   : ${PUSH_ON_FEATURE:-unset}"
    echo "PUSH_IMAGE        : ${PUSH_IMAGE}"
    echo "TAG_SUFFIX        : ${TAG_SUFFIX:-<none>}"
    echo "TAG_LATEST        : ${TAG_LATEST:-false}"
    echo "IMAGE_REPO        : ${IMAGE_REPO}"
    echo "IMAGE_TAG         : ${IMAGE_TAG}"
    echo "---------------------"

    # ---------- Build ----------
    docker build --pull -f "${DOCKERFILE}" \
      --label "org.opencontainers.image.source=${CI_PROJECT_URL:-}" \
      --label "org.opencontainers.image.revision=${CI_COMMIT_SHA:-}" \
      --label "org.opencontainers.image.created=$(date -u +%FT%TZ)" \
      --label "org.opencontainers.image.ref.name=${CI_COMMIT_REF_NAME:-}" \
      --build-arg TOKEN_TYPE="${TOKEN_TYPE}" \
      --build-arg GITLAB_TOKEN="${BUILD_TOKEN}" \
      --build-arg CI_PROJECT_ID="${CI_PROJECT_ID:-}" \
      --build-arg CI_SERVER_URL="${CI_SERVER_URL:-}" \
      -t "${IMAGE_REPO}:${IMAGE_TAG}" "${DOCKER_CONTEXT}"

    # Tag latest for prod branch and tag pipelines
    if [[ "${TAG_LATEST:-false}" == "true" || -n "${IS_TAG}" ]]; then
      docker tag "${IMAGE_REPO}:${IMAGE_TAG}" "${IMAGE_REPO}:latest"
    fi

    # ---------- Push (only if enabled) ----------
    if [[ "${PUSH_IMAGE}" == "true" ]]; then
      if [[ -n "${IS_CI}" ]]; then
        echo "Login ${CI_REGISTRY} as ${CI_REGISTRY_USER}"
        docker login -u "${CI_REGISTRY_USER}" -p "${CI_JOB_TOKEN}" "${CI_REGISTRY}"
      elif [[ -n "${REGISTRY_HOST:-}" && -n "${REGISTRY_USER:-}" && -n "${BUILD_TOKEN:-}" ]]; then
        echo "Login ${REGISTRY_HOST} as ${REGISTRY_USER}"
        echo -n "${BUILD_TOKEN}" | docker login "${REGISTRY_HOST}" --username "${REGISTRY_USER}" --password-stdin
      fi

      echo "Pushing ${IMAGE_REPO}:${IMAGE_TAG}"
      docker push "${IMAGE_REPO}:${IMAGE_TAG}"
      if [[ "${TAG_LATEST:-false}" == "true" || -n "${IS_TAG}" ]]; then
        docker push "${IMAGE_REPO}:latest"
      fi
      DIGEST="$(docker inspect --format='{{index .RepoDigests 0}}' "${IMAGE_REPO}:${IMAGE_TAG}" || true)"
    else
      echo "Skipping push (PUSH_IMAGE=false)"
      DIGEST=""
    fi

    {
      echo "IMAGE_ENV_PATH=${IMAGE_REPO}"
      echo "IMAGE_TAG=${IMAGE_TAG}"
      echo "IMAGE_REF=${DIGEST:-skipped}"
      echo "IMAGE_DIGEST=${DIGEST#*@sha256:}"
    } > image-digest.env

  artifacts:
    reports: { dotenv: image-digest.env }
    paths: [ image-digest.env ]
    when: always
    expire_in: 1 week
