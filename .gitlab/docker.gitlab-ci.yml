.build-dind:
  image: docker:24.0.5
  services:
    - name: docker:24.0.5-dind
      alias: docker
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""



.build-common:
  extends: .build-dind
  variables:
    TAG_LATEST: "false"
    PUSH_IMAGE: "false"
    RELEASE_IMAGE: "false"
    TAG_SUFFIX: ""
    DOCKER_CONTEXT: "."
    DOCKERFILE: "Dockerfile"

    FEATURE_PREFIX: "gmarm-"
    FEATURE_TAG_SUFFIX: ""
    PUSH_ON_FEATURE: "false"

    DEV_BRANCH:  "dev"
    TEST_BRANCH: "test"
    INT_BRANCH:  "int"
    PROD_BRANCH: "prod"

    DEV_TAG_SUFFIX:  "dev"
    TEST_TAG_SUFFIX: "test"
    INT_TAG_SUFFIX:  "int"
    PROD_TAG_SUFFIX: "prod"

    MR_TAG_SUFFIX: "mr"

    # Optional: teams can set APP_NAME explicitly; else we derive from CI_PROJECT_NAME
    # APP_NAME: "my-service"

  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"

  script: |
    # Safe for /bin/sh and bash
    set -euo pipefail 2>/dev/null || set -eu

    # --- Derive IMAGE_ENV_PATH (no double nesting) ---
    if [ -z "${IMAGE_ENV_PATH:-}" ]; then
      if [ -z "${CI_REGISTRY_IMAGE:-}" ]; then
        echo "ERROR: CI_REGISTRY_IMAGE is empty; set IMAGE_ENV_PATH explicitly" >&2
        exit 1
      fi

      if [ -n "${APP_NAME:-}" ]; then
        # sanitize APP_NAME only if provided
        RAW_APP_NAME="${APP_NAME}"
        APP_NAME="$(printf '%s' "${RAW_APP_NAME}" \
          | tr '[:upper:] ' '[:lower:]-' \
          | tr -cd 'a-z0-9._-')"
        if [ -z "${APP_NAME}" ]; then
          echo "ERROR: APP_NAME resolved to empty after sanitization (from '${RAW_APP_NAME}')" >&2
          exit 1
        fi
        IMAGE_ENV_PATH="${CI_REGISTRY_IMAGE}/${APP_NAME}"
      else
        IMAGE_ENV_PATH="${CI_REGISTRY_IMAGE}"
      fi
      echo "Derived IMAGE_ENV_PATH=${IMAGE_ENV_PATH}"
    fi

    # --- Figure out build MODE (for readable logs) ---
    MODE="other"
    if [ "${RELEASE_IMAGE}" = "true" ] || [ -n "${CI_COMMIT_TAG:-}" ]; then
      MODE="release"
    elif [ "${CI_COMMIT_BRANCH:-}" = "${PROD_BRANCH}" ]; then
      MODE="prod"
    elif [ "${CI_COMMIT_BRANCH:-}" = "${INT_BRANCH}" ]; then
      MODE="int"
    elif [ "${CI_COMMIT_BRANCH:-}" = "${TEST_BRANCH}" ]; then
      MODE="test"
    elif [ "${CI_COMMIT_BRANCH:-}" = "${DEV_BRANCH}" ]; then
      MODE="dev"
    elif [ "${CI_PIPELINE_SOURCE:-}" = "merge_request_event" ] && printf '%s' "${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME:-}" | grep -Eq '^'"${FEATURE_PREFIX}" ; then
      MODE="mr"
    elif printf '%s' "${CI_COMMIT_BRANCH:-}" | grep -Eq '^'"${FEATURE_PREFIX}" ; then
      MODE="feature"
    fi

    # --- Guard: suffix 'latest' ---
    if [ "${TAG_SUFFIX}" = "latest" ]; then
      echo "ERROR: TAG_SUFFIX cannot be 'latest' (use TAG_LATEST=true)" >&2
      exit 1
    fi

    # --- Determine base tag (release tag or commit SHA) ---
    if [ "${RELEASE_IMAGE}" = "true" ]; then
      if [ -z "${CI_COMMIT_TAG:-}" ]; then
        echo "ERROR: RELEASE_IMAGE=true requires CI_COMMIT_TAG" >&2
        exit 1
      fi
      RAW_TAG="${CI_COMMIT_TAG}"
      # defaults, without clobbering rule-provided values
      [ "${PUSH_IMAGE:-false}" = "true" ] || PUSH_IMAGE="true"
      : "${TAG_LATEST:=false}"
    else
      RAW_TAG="${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
    fi

    # --- Sanitize for Docker tag ---
    SANITIZED_BASE_TAG="$(printf '%s' "${RAW_TAG}" | tr ' /' '--' | tr -cd '[:alnum:]._-')"
    if [ -z "${SANITIZED_BASE_TAG}" ]; then
      echo "ERROR: Computed image tag is empty after sanitization" >&2
      exit 1
    fi

    # --- Compose final tag ---
    IMAGE_TAG="${TAG_SUFFIX:+${TAG_SUFFIX}-}${SANITIZED_BASE_TAG}"

    # ---- Nice, human logs up front ----
    echo "========================================"
    echo "BUILD MODE        : ${MODE}"
    echo "RELEASE_IMAGE     : ${RELEASE_IMAGE}"
    echo "PUSH_IMAGE        : ${PUSH_IMAGE}"
    echo "TAG_LATEST        : ${TAG_LATEST}"
    echo "TAG_SUFFIX        : ${TAG_SUFFIX}"
    echo "CI_COMMIT_REF     : ${CI_COMMIT_REF_NAME:-}"
    echo "IMAGE_ENV_PATH    : ${IMAGE_ENV_PATH}"
    echo "IMAGE_TAG         : ${IMAGE_TAG}"
    echo "DOCKER_CONTEXT    : ${DOCKER_CONTEXT}"
    echo "DOCKERFILE        : ${DOCKERFILE}"
    echo "========================================"

    # --- Write env file for downstream jobs ---
    {
      echo "IMAGE_ENV_PATH=${IMAGE_ENV_PATH}"
      echo "IMAGE_TAG=${IMAGE_TAG}"
      echo "IMAGE_DIGEST=${IMAGE_DIGEST_VALUE}"
      echo "IMAGE_REF=${IMAGE_REF_VALUE}"
    } > "${CI_PROJECT_DIR}/image-digest.env"

  artifacts:
    reports:
      dotenv: image-digest.env
    paths:
      - image-digest.env
    when: always
    expire_in: 1 week
