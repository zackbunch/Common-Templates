# .gitlab/job-rules.gitlab-ci.yml
#
# Reusable job rules — each block is a hidden job that can be referenced with:
#   rules: !reference [.rule:name-here, rules]
#
# NOTES:
# - "First match wins": GitLab evaluates rules top-to-bottom and stops on the first match.
# - Always end with an explicit `- when: never` to deny all non-matching cases.

# -------------------------------------------------------------------
# Workflow skip push pipeline if an MR already exists.

# -------------------------------------------------------------------
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_TAG || $CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "push"'
      when: always
    - when: never

# -------------------------------------------------------------------
# Example: run scans only when an MR targets dev/test/int/prod/main/master
# -------------------------------------------------------------------
.rule:scan-on-mr-to-env:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^(dev|test|int|prod|main|master)$/'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:scan-manual-non-mr:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: never
    - when: manual
      allow_failure: true

# -------------------------------------------------------------------
.rule:push-or-mr:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:push-branches-only:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_TAG == null'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:tag-only:
  rules:
    - if: '$CI_COMMIT_TAG'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:mr-only:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:manual-anywhere:
  rules:
    - when: manual
      allow_failure: false

# -------------------------------------------------------------------
.rule:default-branch-only:
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:protected-branches-only:
  rules:
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_REF_PROTECTED == "true"'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:protected-tags-only:
  rules:
    - if: '$CI_COMMIT_TAG && $CI_COMMIT_REF_PROTECTED == "true"'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:env-branches-only:
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^(dev|test|int|main|master)$/'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:schedule-only:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:web-or-api-only:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web" || $CI_PIPELINE_SOURCE == "api"'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:rc-tags-only:
  rules:
    - if: '$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ /^[0-9]+\.[0-9]+\.[0-9]+-rc\.[0-9]+$/'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:mr-with-label-security-scan:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_LABELS =~ /(^|, )security-scan(,|$)/'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:skip-draft-mr:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TITLE =~ /^(Draft|WIP):/i'
      when: never
    - when: on_success

# -------------------------------------------------------------------
.rule:changes-only-src:
  rules:
    - changes:
        - src/**/*
        - cmd/**/*
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:skip-docs-only:
  rules:
    - changes:
        - docs/**/*
        - "**/*.md"
      when: never
    - when: on_success

# -------------------------------------------------------------------
.rule:mr-from-fork-only:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_SOURCE_PROJECT_PATH != $CI_PROJECT_PATH'
      when: on_success
    - when: never

# -------------------------------------------------------------------
.rule:mr-same-project-only:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_SOURCE_PROJECT_PATH == $CI_PROJECT_PATH'
      when: on_success
    - when: never

# -------------------------------------------------------------------
# Simple build matrix matching your cadence:
# - Tags: push as release (also :latest)
# - dev branch: push (suffix=dev)
# - MR pipelines: build but DO NOT push (keeps registry clean)
# - Feature pushes: optional push via PUSH_ON_FEATURE (suffix=branch slug)
# -------------------------------------------------------------------
.rule:build-simple:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never

    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      variables:
        PUSH_IMAGE: "true"
        TAG_LATEST: "false"
        # mr-<MR IID>-<pipeline id> keeps tags unique and easy to GC
        TAG_SUFFIX: "mr-${CI_MERGE_REQUEST_IID}-${CI_PIPELINE_ID}"
        DEBUG_REASON: "mr pipeline (temp push)"

    # Tags → release push
    - if: '$CI_COMMIT_TAG'
      variables:
        RELEASE_IMAGE: "true"
        PUSH_IMAGE: "true"
        TAG_SUFFIX: ""
        TAG_LATEST: "true"
        DEBUG_REASON: "tag pipeline"

    # MR pipelines → build only (no push)
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      variables:
        PUSH_IMAGE: "false"
        TAG_SUFFIX: "$CI_COMMIT_REF_SLUG"
        DEBUG_REASON: "mr pipeline (no push)"

    # dev branch → push
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "dev"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "dev"
        DEBUG_REASON: "dev branch push"

    # Other branch pushes (features) → toggle push
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_TAG == null'
      variables:
        PUSH_IMAGE: "$PUSH_ON_FEATURE"
        TAG_SUFFIX: "$CI_COMMIT_REF_SLUG"
        DEBUG_REASON: "feature branch push"


    - when: never
      variables: { DEBUG_REASON: "no matching build rule" }

# -------------------------------------------------------------------
# Scans should run on dev merges and on release tags (your cadence)
# -------------------------------------------------------------------
.rule:scan-dev-or-tag:
  rules:
    - if: '$CI_COMMIT_TAG'                                  # release
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "dev"'  # post-merge to dev
      when: on_success
    - when: never

# -------------------------------------------------------------------
# (Optional) broader scan trigger when an image likely exists
# -------------------------------------------------------------------
.rule:scan-when-image-exists:
  rules:
    - if: '$CI_COMMIT_TAG'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH =~ /^(dev|test|int|prod)$/'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_TAG == null && $PUSH_ON_FEATURE == "true"'
      when: on_success
    - when: never
