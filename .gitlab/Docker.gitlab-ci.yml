workflow:
  rules:
    - if: '$CI_COMMIT_TAG'
      variables: { CI_APPLICATION_REPOSITORY: $CI_REGISTRY_IMAGE, CI_APPLICATION_TAG: $CI_COMMIT_TAG }
    - if: '$CI_COMMIT_BRANCH =~ /\b(dev|test|int|master)\b/'
      variables: { CI_APPLICATION_REPOSITORY: $CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH, CI_APPLICATION_TAG: latest }
    - if: '$CI_COMMIT_BRANCH =~ /^gmarm-\d+/'
      variables: { CI_APPLICATION_REPOSITORY: $CI_REGISTRY_IMAGE/gmarm, CI_APPLICATION_TAG: latest }
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - when: always

variables:
  DOCKER_TLS_CERTDIR: ""
  DOCKER_BUILDKIT: "1"          # buildx uses BuildKit, keep on
  PUSH_FEATURE_BRANCH: "false"

stages: [build]

.before_docker: &before_docker |
  set -eu
  echo "$CI_JOB_TOKEN" | docker login -u gitlab-ci-token --password-stdin "$CI_REGISTRY"

.docker_build_template:
  stage: build
  image: docker:24
  services: ["docker:24-dind"]
  resource_group: "${CI_PROJECT_PATH_SLUG}:${CI_COMMIT_REF_SLUG}:docker-build"
  variables:
    DOCKERFILE: "Dockerfile"
    CONTEXT: "."
    EXTRA_BUILD_ARGS: ""   # raw flags (e.g., --target runtime)
    BUILD_ARGS: ""         # user-supplied key=val -> --build-arg key=val
  script:
    - *before_docker

    # Ensure a named buildx builder (docker:24 includes buildx plugin)
    - |
      set -eu
      if ! docker buildx ls | grep -qE "^ci-builder"; then
        docker buildx create --name ci-builder --driver docker-container --use
      else
        docker buildx use ci-builder
      fi

    # ----- Compute meta -----
    - |
      set -eu
      if [ -n "${CI_APPLICATION_REPOSITORY:-}" ]; then
        BASE_IMAGE_PATH="$CI_APPLICATION_REPOSITORY"
      else
        BASE_IMAGE_PATH="$CI_REGISTRY_IMAGE"
      fi

      if [ -n "${CI_APPLICATION_TAG:-}" ]; then
        IMAGE_TAG="$CI_APPLICATION_TAG"
      elif [ -n "${CI_COMMIT_TAG:-}" ]; then
        IMAGE_TAG="$CI_COMMIT_TAG"
      elif [ "$CI_COMMIT_REF_NAME" = "$CI_DEFAULT_BRANCH" ]; then
        IMAGE_TAG="latest"
      else
        IMAGE_TAG="$CI_COMMIT_REF_SLUG"
      fi

      DOCKER_IMAGE_WITH_TAG="$BASE_IMAGE_PATH:$IMAGE_TAG"
      echo "DOCKER_IMAGE_WITH_TAG=$DOCKER_IMAGE_WITH_TAG"

      WILL_PUSH="false"
      if [ -n "${CI_COMMIT_TAG:-}" ] || [ "$CI_COMMIT_REF_NAME" = "$CI_DEFAULT_BRANCH" ] || [ -n "${CI_MERGE_REQUEST_IID:-}" ]; then
        WILL_PUSH="true"
      elif [ "${PUSH_FEATURE_BRANCH:-false}" = "true" ]; then
        WILL_PUSH="true"
      fi
      echo "WILL_PUSH=$WILL_PUSH"

      SECRET_ARG=""
      [ -n "${CI_JOB_TOKEN:-}" ] && SECRET_ARG="--secret id=gitlab_token,env=CI_JOB_TOKEN"

      # Only user-provided build args
      BUILD_ARG_FLAGS=""
      for kv in $(printf '%s\n' "${BUILD_ARGS:-}" | tr '\n' ' '); do
        [ -n "$kv" ] || continue
        BUILD_ARG_FLAGS="$BUILD_ARG_FLAGS --build-arg $kv"
      done
      EXTRA_BUILD_ARGS="$BUILD_ARG_FLAGS ${EXTRA_BUILD_ARGS:-}"

      # metadata file for buildx to emit digest when pushing
      META_FILE="buildx-metadata.json"

    # ----- Buildx build (push or load) -----
    - |
      set -eu
      BUILD_DATE="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
      LABELS="--label org.opencontainers.image.created=$BUILD_DATE \
              --label org.opencontainers.image.source=$CI_PROJECT_URL \
              --label org.opencontainers.image.revision=$CI_COMMIT_SHA \
              --label org.opencontainers.image.version=$IMAGE_TAG \
              --label org.opencontainers.image.ref.name=$CI_COMMIT_REF_NAME \
              --label org.opencontainers.image.vendor=simulogix"

      if [ "$WILL_PUSH" = "true" ]; then
        # Single-shot build + push; capture digest in metadata
        docker buildx build \
          $SECRET_ARG \
          $LABELS \
          -f "$DOCKERFILE" $EXTRA_BUILD_ARGS \
          -t "$DOCKER_IMAGE_WITH_TAG" "$CONTEXT" \
          --metadata-file "$META_FILE" \
          --push
      else
        # Local-only build (useful for test branches)
        docker buildx build \
          $SECRET_ARG \
          $LABELS \
          -f "$DOCKERFILE" $EXTRA_BUILD_ARGS \
          -t "$DOCKER_IMAGE_WITH_TAG" "$CONTEXT" \
          --load
      fi

    # ----- Compute IMAGE_REF (prefer buildx metadata when pushed) -----
    - |
      set -eu
      IMAGE_REF=""
      if [ "$WILL_PUSH" = "true" ] && [ -s "$META_FILE" ]; then
        # buildx writes .["containerimage.digest"] or .["image.name"][0].digest depending on version
        DIGEST="$(awk -F'"' '/containerimage.digest/ {print $4}' "$META_FILE" || true)"
        if [ -z "$DIGEST" ]; then
          DIGEST="$(grep -Eo '"digest":"sha256:[0-9a-f]+' "$META_FILE" | head -n1 | cut -d':' -f3-)"
          [ -n "$DIGEST" ] && DIGEST="sha256:$DIGEST"
        fi
        [ -n "$DIGEST" ] && IMAGE_REF="${BASE_IMAGE_PATH}@${DIGEST}"
      fi

      # Fallbacks (e.g., no push)
      if [ -z "$IMAGE_REF" ]; then
        # RepoDigests may be empty when not pushed; fall back to tag
        if docker image inspect "$DOCKER_IMAGE_WITH_TAG" >/dev/null 2>&1; then
          DIGEST="$(docker inspect --format='{{index .RepoDigests 0}}' "$DOCKER_IMAGE_WITH_TAG" 2>/dev/null | cut -d'@' -f2 || true)"
          [ -n "$DIGEST" ] && IMAGE_REF="${BASE_IMAGE_PATH}@${DIGEST}"
        fi
      fi
      [ -z "$IMAGE_REF" ] && IMAGE_REF="$DOCKER_IMAGE_WITH_TAG"

      printf 'DOCKER_IMAGE_WITH_TAG=%s\nIMAGE_REF=%s\nCS_IMAGE=%s\n' \
        "$DOCKER_IMAGE_WITH_TAG" "$IMAGE_REF" "$IMAGE_REF" | tee docker.env

  artifacts:
    when: always
    reports: { dotenv: docker.env }
    paths: [ "docker.env" ]
    expire_in: 1 week

  rules:
    - when: on_success