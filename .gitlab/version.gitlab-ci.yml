# .gitlab/version.gitlab-ci.yml
# ─────────────────────────────────────────────────────────────────────
# Reusable job: update_version
# - On tags:   VERSION = $CI_COMMIT_TAG
# - No tag:    VERSION = <ref>-<shortsha>-<pipeline_iid>
# - Emits:     VERSION (file) and version.env (dotenv) for downstream jobs
# ─────────────────────────────────────────────────────────────────────

.update_version_job: &update_version_job
  stage: build
  # Pick something that has /bin/sh; add git only if you keep git-based fallback.
  image: alpine:3.20
  before_script:
    - set -euo pipefail
  script:
    - |
      # Prefer the tag if present
      if [ -n "${CI_COMMIT_TAG:-}" ]; then
        VERSION="${CI_COMMIT_TAG}"
      else
        # Tagless fallback using only CI vars (works with shallow clones)
        # Normalize branch for filenames/labels (replace slashes with dashes)
        SAFE_REF="$(printf '%s' "${CI_COMMIT_REF_NAME}" | tr '/ ' '--')"
        VERSION="${SAFE_REF}-${CI_COMMIT_SHORT_SHA}-${CI_PIPELINE_IID}"
      fi

      # Optional SemVer enforcement on tags
      if [ -n "${CI_COMMIT_TAG:-}" ] && [ "${ENFORCE_SEMVER:-false}" = "true" ]; then
        case "$VERSION" in
          ([0-9]*.[0-9]*.[0-9]*|[0-9]*.[0-9]*.[0-9]*-*) : ;;
          (*) echo "ERROR: Tag '$VERSION' is not SemVer"; exit 1 ;;
        esac
      fi

      echo "$VERSION" > VERSION
      printf 'VERSION=%s\n' "$VERSION" > version.env
      echo "Computed VERSION=$VERSION"
  artifacts:
    paths:
      - VERSION
    reports:
      dotenv: version.env
    expire_in: 1 week
  rules:
    # run on tags
    - if: '$CI_COMMIT_TAG'
    # run on branches (MRs, dev/test/int/prod, features)
    - if: '$CI_COMMIT_BRANCH'
    # optionally skip schedules
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never

# Public job
update_version:
  <<: *update_version_job
