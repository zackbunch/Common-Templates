# -------------------------------------------------------------------
# Example CI Pipeline
# -------------------------------------------------------------------
include:
  - local: '.gitlab/docker.gitlab-ci.yml'
  - local: '.gitlab/deploy.gitlab-ci.yml'
  - local: '.gitlab/secrets.gitlab-ci.yml'

stages: [scan, build, deploy, release]

variables:
  APP_NAME: templates
  DEV_TAG_SUFFIX: "dev"
  TEST_TAG_SUFFIX: "test"
  INT_TAG_SUFFIX:  "int"
  PROD_TAG_SUFFIX: "prod"
  MR_TAG_SUFFIX:   "mr"
  FEATURE_TAG_SUFFIX: "feat"
  PUSH_ON_FEATURE: "false"

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - when: never

# ---------------------------
# Build
# ---------------------------
build:
  stage: build
  extends: .build-common
  # If your .build-common writes image-digest.env, keep it. If not, add it:
  # artifacts:
  #   reports:
  #     dotenv: image-digest.env

  rules:
    # Tag builds → release image
    - if: '$CI_COMMIT_TAG'
      variables:
        RELEASE_IMAGE: "true"
        PUSH_IMAGE: "true"
        TAG_SUFFIX: ""
        TAG_LATEST: "false"

    # MR from gmarm-* → build for review, no push
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^gmarm-/'
      variables:
        PUSH_IMAGE: "false"
        TAG_SUFFIX: "$MR_TAG_SUFFIX"

    # Env branches → build + push
    - if: '$CI_COMMIT_BRANCH == "prod"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$PROD_TAG_SUFFIX"
        TAG_LATEST: "true"

    - if: '$CI_COMMIT_BRANCH == "int"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$INT_TAG_SUFFIX"

    - if: '$CI_COMMIT_BRANCH == "test"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$TEST_TAG_SUFFIX"

    - if: '$CI_COMMIT_BRANCH == "dev"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$DEV_TAG_SUFFIX"

    # Feature branches (gmarm-*) → opt-in push
    - if: '$CI_COMMIT_BRANCH =~ /^gmarm-/'
      variables:
        PUSH_IMAGE: "$PUSH_ON_FEATURE"
        TAG_SUFFIX: "$FEATURE_TAG_SUFFIX"
      when: always

    # Skip everything else
    - when: never

# ---------------------------
# Release
# ---------------------------
# Use native 'release:' keyword, not release-cli. Consume image-digest.env to
# attach the immutable image ref as an asset link.
release:publish:
  stage: release
  needs:
    - job: build
      artifacts: true
  image: registry.gitlab.com/gitlab-org/release-cli:latest  # or alpine:3.20
  rules:
    - if: '$CI_COMMIT_TAG'                 # run only for tag pipelines
      when: on_success
    - when: never

  before_script:
    - if [ -f image-digest.env ]; then source image-digest.env; fi
    # Expect IMAGE_REF like: registry/path/app@sha256:...
    - echo "IMAGE_REF=${IMAGE_REF:-unset}"

  script:
    - echo "Publishing GitLab Release for $CI_COMMIT_TAG"

  release:
    tag_name: "$CI_COMMIT_TAG"
    name: "Release $CI_COMMIT_TAG"
    description: "Automated release from pipeline"
    assets:
      links:
        # Prefer immutable ref over fragile UI links requiring registry ID
        - name: "Container image (immutable)"
          url: "https://${IMAGE_REF:-$CI_REGISTRY_IMAGE/$APP_NAME:$CI_COMMIT_TAG}"
        # Also attach pipeline artifacts bundle (if any)
        - name: "Build artifacts"
          url: "${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/download"