# -------------------------------------------------------------------
# Example CI Pipeline
# -------------------------------------------------------------------
include:
  - local: '.gitlab/job-rules.gitlab-ci.yml'     # ➊ rules first
  - local: '.gitlab/secrets.gitlab-ci.yml'       # scans can !reference rules now
  - local: '.gitlab/docker.gitlab-ci.yml'
  - local: '.gitlab/deploy.gitlab-ci.yml'

stages: [verify, scan, build, deploy, release]

variables:
  APP_NAME: templates
  DEV_TAG_SUFFIX: "dev"
  TEST_TAG_SUFFIX: "test"
  INT_TAG_SUFFIX:  "int"
  PROD_TAG_SUFFIX: "prod"
  MR_TAG_SUFFIX:   "mr"
  FEATURE_TAG_SUFFIX: "feat"
  PUSH_ON_FEATURE: "false"

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - when: never

# ---------------------------
# Build
# ---------------------------
build:
  stage: build
  interruptible: true                     # ➋ cancel stale builds on new commits
  extends: .build-common

  # Ensure downstream jobs can read the immutable ref
  # (uncomment if .build-common doesn't already do this)
  # artifacts:
  #   reports:
  #     dotenv: image-digest.env

  rules:
    # Tag builds → release image
    - if: '$CI_COMMIT_TAG'
      variables:
        RELEASE_IMAGE: "true"
        PUSH_IMAGE: "true"
        TAG_SUFFIX: ""
        TAG_LATEST: "false"

    # MR from gmarm-* → build for review, no push
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^gmarm-/'
      variables:
        PUSH_IMAGE: "false"
        TAG_SUFFIX: "$MR_TAG_SUFFIX"

    # Env branches → build + push
    - if: '$CI_COMMIT_BRANCH == "prod"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$PROD_TAG_SUFFIX"
        TAG_LATEST: "true"

    - if: '$CI_COMMIT_BRANCH == "int"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$INT_TAG_SUFFIX"

    - if: '$CI_COMMIT_BRANCH == "test"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$TEST_TAG_SUFFIX"

    - if: '$CI_COMMIT_BRANCH == "dev"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$DEV_TAG_SUFFIX"

    # Feature branches (gmarm-*) → opt-in push
    - if: '$CI_COMMIT_BRANCH =~ /^gmarm-/'
      variables:
        PUSH_IMAGE: "$PUSH_ON_FEATURE"
        TAG_SUFFIX: "$FEATURE_TAG_SUFFIX"
      when: always

    # Skip everything else
    - when: never

release:create:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules: !reference [.rule:tag-only, rules]   # ← only run for tag pipelines
  needs:
    - job: build
      artifacts: true
  before_script:
    - NOTES=RELEASE_NOTES.md
    - IMAGE="(not available)"
    - if [ -f image-digest.env ]; then . image-digest.env; IMAGE="${IMAGE_REF}"; fi
    - |
      {
        echo "Release ${CI_COMMIT_TAG}"
        echo
        echo "Pipeline: ${CI_PIPELINE_URL}"
        echo "Commit:   ${CI_PROJECT_URL}/-/commit/${CI_COMMIT_SHA}"
        echo
        echo "Image:"
        echo "\`${IMAGE}\`"
      } > "${NOTES}"
  script:
    - release-cli create
        --name "Release ${CI_COMMIT_TAG}"
        --tag-name "${CI_COMMIT_TAG}"
        --description "$(cat "${NOTES}")"