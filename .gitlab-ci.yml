# -------------------------------------------------------------------
# Example CI Pipeline
# -------------------------------------------------------------------
# Stages:
#   1. Scan    - Runs secrets scan from .gitlab/secrets.gitlab-ci.yml
#   2. Build   - Uses .build-common from .gitlab/docker.gitlab-ci.yml
#   4. Deploy  - Uses jobs from .gitlab/deploy.gitlab-ci.yml
#
# Notes:
#   - Secrets job is dev-only (rules inside secrets.gitlab-ci.yml)
#   - Build pushes on env branches and tags; skips on others
#   - Deploy jobs pick up build artifacts (image-digest.env) for exact image refs
# -------------------------------------------------------------------

include:
  - local: '.gitlab/docker.gitlab-ci.yml'
  - local: '.gitlab/deploy.gitlab-ci.yml'
  - local: '.gitlab/secrets.gitlab-ci.yml'

stages:
  - scan
  - build
  - deploy
  - release

# Default variables for this project
variables:
  APP_NAME: templates

  # Tag suffixes (override at group/project level if needed)
  DEV_TAG_SUFFIX: "dev"
  TEST_TAG_SUFFIX: "test"
  INT_TAG_SUFFIX: "int"
  PROD_TAG_SUFFIX: "prod"
  MR_TAG_SUFFIX: "mr"
  FEATURE_TAG_SUFFIX: "feat"

  # Feature branches only push if explicitly enabled
  PUSH_ON_FEATURE: "false"

# Only run pipelines on pushes or MRs
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - when: never

# ---------------------------
# Build job
# ---------------------------
build:
  stage: build
  extends: .build-common
  # variables:
  #   IMAGE_ENV_PATH: "$CI_REGISTRY_IMAGE/$APP_NAME"

  rules:
    # Tag builds → release image
    - if: '$CI_COMMIT_TAG'
      variables:
        RELEASE_IMAGE: "true"
        PUSH_IMAGE: "true"
        TAG_SUFFIX: ""
        TAG_LATEST: "false"   # :latest only for prod

    # MR from gmarm-* → build for review, no push
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^gmarm-/'
      variables:
        PUSH_IMAGE: "false"
        TAG_SUFFIX: "$MR_TAG_SUFFIX"

    # Env branches → build + push
    - if: '$CI_COMMIT_BRANCH == "prod"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$PROD_TAG_SUFFIX"
        TAG_LATEST: "true"

    - if: '$CI_COMMIT_BRANCH == "int"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$INT_TAG_SUFFIX"

    - if: '$CI_COMMIT_BRANCH == "test"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$TEST_TAG_SUFFIX"

    - if: '$CI_COMMIT_BRANCH == "dev"'
      variables:
        PUSH_IMAGE: "true"
        TAG_SUFFIX: "$DEV_TAG_SUFFIX"

    # Feature branches (gmarm-*) → opt-in push
    - if: '$CI_COMMIT_BRANCH =~ /^gmarm-/'
      variables:
        PUSH_IMAGE: "$PUSH_ON_FEATURE"
        TAG_SUFFIX: "$FEATURE_TAG_SUFFIX"
      when: always

    # Skip everything else
    - when: never



release:publish:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    - if: '$CI_COMMIT_TAG'      # only when you push a tag
  script:
    - echo "Creating GitLab Release for $CI_COMMIT_TAG"
  release:
    tag_name: "$CI_COMMIT_TAG"
    name: "Release $CI_COMMIT_TAG"
    description: "Automated release from pipeline"
    # optional assets (point to job artifacts, package URLs, etc.)
    assets:
      links:
        - name: "artifact.tar.gz"
          url: "${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/download"

